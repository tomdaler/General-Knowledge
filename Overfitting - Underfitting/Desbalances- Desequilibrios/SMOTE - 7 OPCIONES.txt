!pip install imbalanced-learn 

X1 = df2.drop('Churn',axis='columns')
Y1 = df2['Churn']


OPTION 1
========

from imblearn.over_sampling import SMOTE
oversample = SMOTE()
x, y = oversample.fit_resample(X1, Y1)

=> X1 de 7,032 a x de 10,326


OPTION 2
========
from sklearn.datasets import make_classification
from imblearn.over_sampling import SMOTE
from imblearn.under_sampling import RandomUnderSampler
from imblearn.pipeline import Pipeline

# 2 RATIOS A MODIFICAR
over = SMOTE(sampling_strategy=0.5)
under = RandomUnderSampler(sampling_strategy=0.5)

steps = [('o', over), ('u', under)]
pipeline = Pipeline(steps=steps)

# transform the dataset
X, y = pipeline.fit_resample(X1, Y1)


OPTION 3
========


from numpy import mean
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import RepeatedStratifiedKFold
from sklearn.tree import DecisionTreeClassifier
from imblearn.pipeline import Pipeline
from imblearn.over_sampling import SMOTE

# define pipeline
steps = [('over', SMOTE()), ('model', DecisionTreeClassifier())]
pipeline = Pipeline(steps=steps)

# evaluate pipeline
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)
scores = cross_val_score(pipeline, X1, Y1, scoring='roc_auc', cv=cv, n_jobs=-1)
print('Mean ROC AUC: %.3f' % mean(scores))

Output:
Mean ROC AUC: 0.660


OPTION 4
========
MODIFICA RATIOS PARA CONSEGUIR EL MAYOR ROC AUC
r1 = 0.5
r2 = 0.9


from numpy import mean
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import RepeatedStratifiedKFold
from sklearn.tree import DecisionTreeClassifier
from imblearn.pipeline import Pipeline
from imblearn.over_sampling import SMOTE

r1 = 0.5
r2 = 0.9

model = DecisionTreeClassifier()
over = SMOTE(sampling_strategy=r1)
under = RandomUnderSampler(sampling_strategy=r2)

steps = [('over', over), ('under', under), ('model', model)]
pipeline = Pipeline(steps=steps)

# evaluate pipeline
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)
scores = cross_val_score(pipeline, X1, Y1, scoring='roc_auc', cv=cv, n_jobs=-1)
print('Mean ROC AUC: %.3f' % mean(scores))

Output
   Mean ROC AUC: 0.68


OPTION 5
========

from sklearn.datasets import make_classification
from imblearn.over_sampling import BorderlineSMOTE


oversample = BorderlineSMOTE()
X, y = oversample.fit_resample(X1, Y1)



OPTION 6 Borderline-SMOTE SVM
========
from sklearn.datasets import make_classification
from imblearn.over_sampling import SVMSMOTE

oversample = SVMSMOTE()
X, y = oversample.fit_resample(X1, Y1)


OPTION 7
========
generating synthetic samples inversely proportional to the density of the examples in the minority class.

from sklearn.datasets import make_classification
from imblearn.over_sampling import ADASYN

oversample = ADASYN()
X, y = oversample.fit_resample(X1, Y1)


