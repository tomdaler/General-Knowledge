
Las imagenes mejor en gris, 1 canal

Las imagenes a color 3 canales, usarlas cuando el color importa para la decision

Imagenes a color y Alfa, 4 canales, alfa es la transparencia

se denomina RGBA.

Keras (tf.keras.preprocessing.image_dataset_from_directory) 

puede trabajar con estos formatos: “grayscale”, “rgb”, “rgba”. Default: “rgb”. 
Whether the images will be converted to have 1, 3, or 4 channels


Un pequeño código para chequear la predicción de una sola imagen:

image_selected = 10

img = train_images[image_selected ]
img = image.img_to_array(img)
img = np.expand_dims(img, axis = 0)

print(model.predict(img))

print(train_labels[image_selected])


Importante: si imagen es 28x28 asi sera la entrada

Se puede usar data augmentation, donde se aumenta el set de imagenes
Se les cambia un poco, posicion, rotacion, inclinacion, transparencia, 
y asi se tiene mas set de entrenamiento



#Extraer Capas R G y B de la img:
Cr = Im[:,:,0]
Cg = Im[:,:,1]
Cb = Im[:,:,2]

#Dimensión de la imagen:
fil,col,capas = Im.shape

#Calculo la mitad del alto y ancho de la img:
y = int(fil/2)
x = int(col/2)

#Imagen auxiliar de zeros:
aux_dim = np.zeros([y,x])

#Genero cuadrante 1:
aux_C1 = Im[0:y,0:x]

#Genero cuadrante 2:
r_aux = Cr[0:y,x:col]
aux_C2 = np.dstack((r_aux,aux_dim,aux_dim)).astype(np.uint8)

#Genero cuadrante 3:
g_aux = Cg[y:fil,0:x]
aux_C3 = np.dstack((aux_dim,g_aux,aux_dim)).astype(np.uint8)

#Genero cuadrante 4:
b_aux = Cb[y:fil,x:col]
aux_C4 = np.dstack((aux_dim,aux_dim,b_aux)).astype(np.uint8)

#Contatenar la parte de arriba y de abajo
ParteArriba = cv2.hconcat([aux_C1,aux_C2])
ParteAbajo = cv2.hconcat([aux_C3,aux_C4])

#Concatenar imagen final 
ImgFinal = cv2.vconcat([ParteArriba,ParteAbajo])

plt.figure()
plt.figure(figsize=(7,7))
plt.imshow(ImgFinal)

